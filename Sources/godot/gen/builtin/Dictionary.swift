/// autogenerated

import godot_native

fileprivate var __godot_name_Dictionary: StringName! = nil

/// Dictionary type.
/// 
/// Dictionary type. Associative container, which contains values referenced by unique keys. Dictionaries are composed of pairs of keys (which must be unique) and values. Dictionaries will preserve the insertion order when adding new entries. In other programming languages, this data structure is sometimes referred to as a hash map or associative array.
///  
/// You can define a dictionary by placing a comma-separated list of [code]key: value[/code] pairs in curly braces [code]{}[/code].
///  
/// [b]Note:[/b] Dictionaries are always passed by reference. To get a copy of a dictionary which can be modified independently of the original dictionary, use [method duplicate].
///  
/// Creating a dictionary:
///  
/// [codeblocks]
///  
/// [gdscript]
///  
/// var my_dict = {} # Creates an empty dictionary.
///  
///  
/// var dict_variable_key = "Another key name"
///  
/// var dict_variable_value = "value2"
///  
/// var another_dict = {
///  
///     "Some key name": "value1",
///  
///     dict_variable_key: dict_variable_value,
///  
/// }
///  
///  
/// var points_dict = {"White": 50, "Yellow": 75, "Orange": 100}
///  
///  
/// # Alternative Lua-style syntax.
///  
/// # Doesn't require quotes around keys, but only string constants can be used as key names.
///  
/// # Additionally, key names must start with a letter or an underscore.
///  
/// # Here, `some_key` is a string literal, not a variable!
///  
/// another_dict = {
///  
///     some_key = 42,
///  
/// }
///  
/// [/gdscript]
///  
/// [csharp]
///  
/// var myDict = new Godot.Collections.Dictionary(); // Creates an empty dictionary.
///  
/// var pointsDict = new Godot.Collections.Dictionary
///  
/// {
///  
///     {"White", 50},
///  
///     {"Yellow", 75},
///  
///     {"Orange", 100}
///  
/// };
///  
/// [/csharp]
///  
/// [/codeblocks]
///  
/// You can access a dictionary's value by referencing its corresponding key. In the above example, [code]points_dict["White"][/code] will return [code]50[/code]. You can also write [code]points_dict.White[/code], which is equivalent. However, you'll have to use the bracket syntax if the key you're accessing the dictionary with isn't a fixed string (such as a number or variable).
///  
/// [codeblocks]
///  
/// [gdscript]
///  
/// @export_enum("White", "Yellow", "Orange") var my_color: String
///  
/// var points_dict = {"White": 50, "Yellow": 75, "Orange": 100}
///  
/// func _ready():
///  
///     # We can't use dot syntax here as `my_color` is a variable.
///  
///     var points = points_dict[my_color]
///  
/// [/gdscript]
///  
/// [csharp]
///  
/// [Export(PropertyHint.Enum, "White,Yellow,Orange")]
///  
/// public string MyColor { get; set; }
///  
/// private Godot.Collections.Dictionary _pointsDict = new Godot.Collections.Dictionary
///  
/// {
///  
///     {"White", 50},
///  
///     {"Yellow", 75},
///  
///     {"Orange", 100}
///  
/// };
///  
///  
/// public override void _Ready()
///  
/// {
///  
///     int points = (int)_pointsDict[MyColor];
///  
/// }
///  
/// [/csharp]
///  
/// [/codeblocks]
///  
/// In the above code, [code]points[/code] will be assigned the value that is paired with the appropriate color selected in [code]my_color[/code].
///  
/// Dictionaries can contain more complex data:
///  
/// [codeblocks]
///  
/// [gdscript]
///  
/// var my_dict = {
///  
///     "First Array": [1, 2, 3, 4] # Assigns an Array to a String key.
///  
/// }
///  
/// [/gdscript]
///  
/// [csharp]
///  
/// var myDict = new Godot.Collections.Dictionary
///  
/// {
///  
///     {"First Array", new Godot.Collections.Array{1, 2, 3, 4}}
///  
/// };
///  
/// [/csharp]
///  
/// [/codeblocks]
///  
/// To add a key to an existing dictionary, access it like an existing key and assign to it:
///  
/// [codeblocks]
///  
/// [gdscript]
///  
/// var points_dict = {"White": 50, "Yellow": 75, "Orange": 100}
///  
/// points_dict["Blue"] = 150 # Add "Blue" as a key and assign 150 as its value.
///  
/// [/gdscript]
///  
/// [csharp]
///  
/// var pointsDict = new Godot.Collections.Dictionary
///  
/// {
///  
///     {"White", 50},
///  
///     {"Yellow", 75},
///  
///     {"Orange", 100}
///  
/// };
///  
/// pointsDict["Blue"] = 150; // Add "Blue" as a key and assign 150 as its value.
///  
/// [/csharp]
///  
/// [/codeblocks]
///  
/// Finally, dictionaries can contain different types of keys and values in the same dictionary:
///  
/// [codeblocks]
///  
/// [gdscript]
///  
/// # This is a valid dictionary.
///  
/// # To access the string "Nested value" below, use `my_dict.sub_dict.sub_key` or `my_dict["sub_dict"]["sub_key"]`.
///  
/// # Indexing styles can be mixed and matched depending on your needs.
///  
/// var my_dict = {
///  
///     "String Key": 5,
///  
///     4: [1, 2, 3],
///  
///     7: "Hello",
///  
///     "sub_dict": {"sub_key": "Nested value"},
///  
/// }
///  
/// [/gdscript]
///  
/// [csharp]
///  
/// // This is a valid dictionary.
///  
/// // To access the string "Nested value" below, use `((Godot.Collections.Dictionary)myDict["sub_dict"])["sub_key"]`.
///  
/// var myDict = new Godot.Collections.Dictionary {
///  
///     {"String Key", 5},
///  
///     {4, new Godot.Collections.Array{1,2,3}},
///  
///     {7, "Hello"},
///  
///     {"sub_dict", new Godot.Collections.Dictionary{{"sub_key", "Nested value"}}}
///  
/// };
///  
/// [/csharp]
///  
/// [/codeblocks]
///  
/// The keys of a dictionary can be iterated with the [code]for[/code] keyword:
///  
/// [codeblocks]
///  
/// [gdscript]
///  
/// var groceries = {"Orange": 20, "Apple": 2, "Banana": 4}
///  
/// for fruit in groceries:
///  
///     var amount = groceries[fruit]
///  
/// [/gdscript]
///  
/// [csharp]
///  
/// var groceries = new Godot.Collections.Dictionary{{"Orange", 20}, {"Apple", 2}, {"Banana", 4}};
///  
/// foreach (var (fruit, amount) in groceries)
///  
/// {
///  
///     // `fruit` is the key, `amount` is the value.
///  
/// }
///  
/// [/csharp]
///  
/// [/codeblocks]
///  
/// [b]Note:[/b] Erasing elements while iterating over dictionaries is [b]not[/b] supported and will result in unpredictable behavior.
///  
/// [b]Note:[/b] When declaring a dictionary with [code]const[/code], the dictionary becomes read-only. A read-only Dictionary's entries cannot be overridden at run-time. This does [i]not[/i] affect nested [Array] and [Dictionary] values.
public class Dictionary : BuiltinClass {

    

    public class var __godot_name: StringName { __godot_name_Dictionary }

    public static let SIZE = 8;

    public let opaque: UnsafeMutableRawPointer
    
    static var _constructor_0: GDExtensionPtrConstructor? = nil
    static var _constructor_1: GDExtensionPtrConstructor? = nil
    static var _destructor: GDExtensionPtrDestructor? = nil

    public class func initialize_class() {
        // Init constructors before assigning __godot_name
        Dictionary._constructor_0 =  Dictionary.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_DICTIONARY, 0)
        assert(Dictionary._constructor_0 != nil)
        Dictionary._constructor_1 =  Dictionary.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_DICTIONARY, 1)
        assert(Dictionary._constructor_1 != nil)
        Dictionary._destructor =  Dictionary.interface.pointee.variant_get_ptr_destructor(GDEXTENSION_VARIANT_TYPE_DICTIONARY)
        assert(Dictionary._destructor != nil)

        // At this point constructors must be assigned
        __godot_name_Dictionary = StringName(from: "Dictionary")
    }

    /// Constructs an empty [Dictionary].
    public init() {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 0)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                
            ])
            // call here
            Self._constructor_0!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Returns the same dictionary as [param from]. If you need a copy of the dictionary, use [method duplicate].
    public init(from: Dictionary) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_1!(self._native_ptr(), .init(args.baseAddress!))
    }
    public required init(from unsafe: UnsafeRawPointer) {
        self.opaque = .init(mutating: unsafe)
    }
    public required init(from unsafe: UnsafeMutableRawPointer) {
        self.opaque = unsafe
    }

    deinit {
        Self._destructor?(self._native_ptr())
        opaque.deallocate()
    }
}