/// autogenerated

import godot_native

fileprivate var __godot_name_Array: StringName! = nil

/// A generic array datatype.
/// 
/// A generic array that can contain several elements of any type, accessible by a numerical index starting at 0. Negative indices can be used to count from the back, like in Python (-1 is the last element, -2 is the second to last, etc.).
///  
/// [b]Example:[/b]
///  
/// [codeblocks]
///  
/// [gdscript]
///  
/// var array = ["One", 2, 3, "Four"]
///  
/// print(array[0]) # One.
///  
/// print(array[2]) # 3.
///  
/// print(array[-1]) # Four.
///  
/// array[2] = "Three"
///  
/// print(array[-2]) # Three.
///  
/// [/gdscript]
///  
/// [csharp]
///  
/// var array = new Godot.Collections.Array{"One", 2, 3, "Four"};
///  
/// GD.Print(array[0]); // One.
///  
/// GD.Print(array[2]); // 3.
///  
/// GD.Print(array[array.Count - 1]); // Four.
///  
/// array[2] = "Three";
///  
/// GD.Print(array[array.Count - 2]); // Three.
///  
/// [/csharp]
///  
/// [/codeblocks]
///  
/// Arrays can be concatenated using the [code]+[/code] operator:
///  
/// [codeblocks]
///  
/// [gdscript]
///  
/// var array1 = ["One", 2]
///  
/// var array2 = [3, "Four"]
///  
/// print(array1 + array2) # ["One", 2, 3, "Four"]
///  
/// [/gdscript]
///  
/// [csharp]
///  
/// // Array concatenation is not possible with C# arrays, but is with Godot.Collections.Array.
///  
/// var array1 = new Godot.Collections.Array{"One", 2};
///  
/// var array2 = new Godot.Collections.Array{3, "Four"};
///  
/// GD.Print(array1 + array2); // Prints [One, 2, 3, Four]
///  
/// [/csharp]
///  
/// [/codeblocks]
///  
/// [b]Note:[/b] Concatenating with the [code]+=[/code] operator will create a new array, which has a cost. If you want to append another array to an existing array, [method append_array] is more efficient.
///  
/// [b]Note:[/b] Arrays are always passed by reference. To get a copy of an array that can be modified independently of the original array, use [method duplicate].
///  
/// [b]Note:[/b] Erasing elements while iterating over arrays is [b]not[/b] supported and will result in unpredictable behavior.
///  
/// [b]Note:[/b] When declaring an array with [code]const[/code], the array itself can still be mutated by defining the values at individual indices or pushing/removing elements. Using [code]const[/code] will only prevent assigning the constant with another value after it was initialized.
public class Array : BuiltinClass {

    public static var interface: UnsafePointer<GDExtensionInterface>! = nil
    public static var library: GDExtensionClassLibraryPtr! = nil
    
    var interface: UnsafePointer<GDExtensionInterface> { Self.interface }

    

    public class var __godot_name: StringName { __godot_name_Array }

    public static let SIZE = 8;

    public let opaque: UnsafeMutableRawPointer
    
    static var _constructor_0: GDExtensionPtrConstructor? = nil
    static var _constructor_1: GDExtensionPtrConstructor? = nil
    static var _constructor_2: GDExtensionPtrConstructor? = nil
    static var _constructor_3: GDExtensionPtrConstructor? = nil
    static var _constructor_4: GDExtensionPtrConstructor? = nil
    static var _constructor_5: GDExtensionPtrConstructor? = nil
    static var _constructor_6: GDExtensionPtrConstructor? = nil
    static var _constructor_7: GDExtensionPtrConstructor? = nil
    static var _constructor_8: GDExtensionPtrConstructor? = nil
    static var _constructor_9: GDExtensionPtrConstructor? = nil
    static var _constructor_10: GDExtensionPtrConstructor? = nil
    static var _constructor_11: GDExtensionPtrConstructor? = nil
    static var _destructor: GDExtensionPtrDestructor? = nil

    public class func initialize_class(_ ginit: GodotInitializer, _: GDExtensionInitializationLevel) {
        Self.interface = ginit.p_interface
        Self.library = ginit.p_library

        // Init constructors before assigning __godot_name
        Array._constructor_0 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 0)
        assert(Array._constructor_0 != nil)
        Array._constructor_1 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 1)
        assert(Array._constructor_1 != nil)
        Array._constructor_2 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 2)
        assert(Array._constructor_2 != nil)
        Array._constructor_3 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 3)
        assert(Array._constructor_3 != nil)
        Array._constructor_4 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 4)
        assert(Array._constructor_4 != nil)
        Array._constructor_5 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 5)
        assert(Array._constructor_5 != nil)
        Array._constructor_6 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 6)
        assert(Array._constructor_6 != nil)
        Array._constructor_7 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 7)
        assert(Array._constructor_7 != nil)
        Array._constructor_8 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 8)
        assert(Array._constructor_8 != nil)
        Array._constructor_9 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 9)
        assert(Array._constructor_9 != nil)
        Array._constructor_10 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 10)
        assert(Array._constructor_10 != nil)
        Array._constructor_11 =  Array.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_ARRAY, 11)
        assert(Array._constructor_11 != nil)
        Array._destructor =  Array.interface.pointee.variant_get_ptr_destructor(GDEXTENSION_VARIANT_TYPE_ARRAY)
        assert(Array._destructor != nil)
    }

    public class func initialize_godot_name() {
        // At this point constructors for String and StringName
        // must be assigned
        __godot_name_Array = StringName(from: "Array")
    }

    /// Constructs an empty [Array].
    public init() {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 0)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                
            ])
            // call here
            Self._constructor_0!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Creates a typed array from the [param base] array.
    public init(from: Array) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_1!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Returns the same array as [param from]. If you need a copy of the array, use [method duplicate].
    public init(base: Array, `type`: Int64, class_name: StringName, script: Variant) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        withUnsafePointer(to: `type`) { type_native in
        let script_native = script._native_ptr()
        let class_name_native = class_name._native_ptr()
        let base_native = base._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 4)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(base_native), .init(type_native), .init(class_name_native), .init(script_native)
            ])
            // call here
            Self._constructor_2!(self._native_ptr(), .init(args.baseAddress!))
        }
    }
    /// Constructs an array from a [PackedByteArray].
    public init(from: PackedByteArray) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_3!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs an array from a [PackedColorArray].
    public init(from: PackedInt32Array) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_4!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs an array from a [PackedFloat32Array].
    public init(from: PackedInt64Array) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_5!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs an array from a [PackedFloat64Array].
    public init(from: PackedFloat32Array) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_6!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs an array from a [PackedInt32Array].
    public init(from: PackedFloat64Array) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_7!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs an array from a [PackedInt64Array].
    public init(from: PackedStringArray) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_8!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs an array from a [PackedStringArray].
    public init(from: PackedVector2Array) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_9!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs an array from a [PackedVector2Array].
    public init(from: PackedVector3Array) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_10!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs an array from a [PackedVector3Array].
    public init(from: PackedColorArray) {
        self.opaque = .allocate(byteCount: 8, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_11!(self._native_ptr(), .init(args.baseAddress!))
    }
    public required init(godot unsafe: UnsafeRawPointer) {
        self.opaque = .init(mutating: unsafe)
    }
    public required init(godot unsafe: UnsafeMutableRawPointer) {
        self.opaque = unsafe
    }

    deinit {
        Self._destructor?(self._native_ptr())
        opaque.deallocate()
    }
}