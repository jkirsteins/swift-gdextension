/// autogenerated

import godot_native

fileprivate var __godot_name_Transform2D: StringName! = nil

/// 2D transformation (2×3 matrix).
/// 
/// 2×3 matrix (2 rows, 3 columns) used for 2D linear transformations. It can represent transformations such as translation, rotation, or scaling. It consists of three [Vector2] values: [member x], [member y], and the [member origin].
///  
/// For more information, read the "Matrices and transforms" documentation article.
public class Transform2D : BuiltinClass {

    

    public class var __godot_name: StringName { __godot_name_Transform2D }

    public static let SIZE = 48;

    public let opaque: UnsafeMutableRawPointer
    
    static var _constructor_0: GDExtensionPtrConstructor? = nil
    static var _constructor_1: GDExtensionPtrConstructor? = nil
    static var _constructor_2: GDExtensionPtrConstructor? = nil
    static var _constructor_3: GDExtensionPtrConstructor? = nil
    static var _constructor_4: GDExtensionPtrConstructor? = nil
    static var _destructor: GDExtensionPtrDestructor? = nil

    public class func initialize_class() {
        // Init constructors before assigning __godot_name
        Transform2D._constructor_0 =  Transform2D.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 0)
        assert(Transform2D._constructor_0 != nil)
        Transform2D._constructor_1 =  Transform2D.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 1)
        assert(Transform2D._constructor_1 != nil)
        Transform2D._constructor_2 =  Transform2D.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 2)
        assert(Transform2D._constructor_2 != nil)
        Transform2D._constructor_3 =  Transform2D.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 3)
        assert(Transform2D._constructor_3 != nil)
        Transform2D._constructor_4 =  Transform2D.interface.pointee.variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_TRANSFORM2D, 4)
        assert(Transform2D._constructor_4 != nil)
        Transform2D._destructor =  Transform2D.interface.pointee.variant_get_ptr_destructor(GDEXTENSION_VARIANT_TYPE_TRANSFORM2D)
        assert(Transform2D._destructor != nil)

        // At this point constructors must be assigned
        __godot_name_Transform2D = StringName(from: "Transform2D")
    }

    /// Constructs a default-initialized [Transform2D] set to [constant IDENTITY].
    public init() {
        self.opaque = .allocate(byteCount: 48, alignment: 4)
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 0)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                
            ])
            // call here
            Self._constructor_0!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs a [Transform2D] as a copy of the given [Transform2D].
    public init(from: Transform2D) {
        self.opaque = .allocate(byteCount: 48, alignment: 4)
        let from_native = from._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 1)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(from_native)
            ])
            // call here
            Self._constructor_1!(self._native_ptr(), .init(args.baseAddress!))
    }
    /// Constructs the transform from a given angle (in radians) and position.
    public init(rotation: Float64, position: Vector2) {
        self.opaque = .allocate(byteCount: 48, alignment: 4)
        withUnsafePointer(to: rotation) { rotation_native in
        let position_native = position._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 2)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(rotation_native), .init(position_native)
            ])
            // call here
            Self._constructor_2!(self._native_ptr(), .init(args.baseAddress!))
        }
    }
    /// Constructs the transform from a given angle (in radians), scale, skew (in radians) and position.
    public init(rotation: Float64, scale: Vector2, skew: Float64, position: Vector2) {
        self.opaque = .allocate(byteCount: 48, alignment: 4)
        withUnsafePointer(to: skew) { skew_native in
        withUnsafePointer(to: rotation) { rotation_native in
        let position_native = position._native_ptr()
        let scale_native = scale._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 4)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(rotation_native), .init(scale_native), .init(skew_native), .init(position_native)
            ])
            // call here
            Self._constructor_3!(self._native_ptr(), .init(args.baseAddress!))
        }
        }
    }
    /// Constructs the transform from 3 [Vector2] values representing [member x], [member y], and the [member origin] (the three column vectors).
    public init(x_axis: Vector2, y_axis: Vector2, origin: Vector2) {
        self.opaque = .allocate(byteCount: 48, alignment: 4)
        let origin_native = origin._native_ptr()
        let y_axis_native = y_axis._native_ptr()
        let x_axis_native = x_axis._native_ptr()
        let args: UnsafeMutableBufferPointer<GDExtensionConstTypePtr?> = .allocate(capacity: 3)
            defer { args.deallocate() }
            _ = args.initialize(from: [
                .init(x_axis_native), .init(y_axis_native), .init(origin_native)
            ])
            // call here
            Self._constructor_4!(self._native_ptr(), .init(args.baseAddress!))
    }
    public required init(from unsafe: UnsafeRawPointer) {
        self.opaque = .init(mutating: unsafe)
    }
    public required init(from unsafe: UnsafeMutableRawPointer) {
        self.opaque = unsafe
    }

    deinit {
        Self._destructor?(self._native_ptr())
        opaque.deallocate()
    }
}